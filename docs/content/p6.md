# Métodos Asíncronos y Fetch en JavaScript con Mockoon

## Introducción

JavaScript es un lenguaje de programación que, por naturaleza, es **síncrono** y de un solo hilo, lo que significa que ejecuta una tarea a la vez en un orden secuencial. Sin embargo, muchas operaciones, como solicitudes HTTP, acceso a bases de datos o lectura de archivos, son **asíncronas** porque pueden tardar un tiempo indeterminado en completarse. Para manejar estas operaciones, JavaScript proporciona mecanismos como **callbacks**, **promesas**, y las palabras clave **`async/await`**, junto con la API moderna **`fetch`** para realizar solicitudes HTTP.

En este documento, exploraremos en detalle:

1. **¿Qué es la programación asíncrona?**
2. **Mecanismos para manejar asincronía en JavaScript**:
   - Callbacks
   - Promesas
   - Async/Await
3. **La API `fetch`: cómo realizar solicitudes HTTP**
4. **Uso de Mockoon para simular APIs**
5. **Ejemplos prácticos completos con Mockoon**
6. **Buenas prácticas y manejo de errores**

Además, se incluirán ejemplos específicos utilizando **Mockoon**, una herramienta que permite crear servidores API simulados para pruebas locales, ideal para desarrolladores que necesitan probar solicitudes HTTP sin depender de un servidor remoto.

---

## ¿Qué es la programación asíncrona?

La programación asíncrona permite que el código continúe ejecutándose mientras se espera que una operación de larga duración (como una solicitud HTTP) se complete, sin bloquear el hilo principal. Esto es crucial en aplicaciones web para mejorar la experiencia del usuario, ya que evita que la interfaz se "congele" mientras se espera una respuesta.

JavaScript utiliza el **event loop** (bucle de eventos) para manejar operaciones asíncronas. El event loop permite que las tareas asíncronas se procesen en segundo plano y se ejecuten una vez que estén listas, mientras el resto del código sigue ejecutándose.

---

## Mecanismos para manejar asincronía en JavaScript

### 1. Callbacks

Los **callbacks** son funciones que se pasan como argumentos a otras funciones y se ejecutan una vez que la operación asíncrona ha terminado. Aunque son un enfoque antiguo, es importante entenderlos porque son la base de los métodos modernos.

#### Ejemplo de callback

```javascript
function obtenerDatos(url, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.onload = function () {
    if (xhr.status === 200) {
      callback(null, JSON.parse(xhr.responseText));
    } else {
      callback(new Error('Error en la solicitud'), null);
    }
  };
  xhr.onerror = function () {
    callback(new Error('Error de red'), null);
  };
  xhr.send();
}

obtenerDatos('http://localhost:3000/datos', function (error, datos) {
  if (error) {
    console.error('Error:', error.message);
    return;
  }
  console.log('Datos recibidos:', datos);
});
```

**Problema con callbacks**: Cuando se anidan múltiples callbacks, se genera el problema conocido como **"callback hell"** o "pirámide de la fatalidad", que hace que el código sea difícil de leer y mantener.

### 2. Promesas

Las **promesas** son objetos que representan la eventual finalización (o falla) de una operación asíncrona. Una promesa puede estar en uno de tres estados:

- **Pending** (pendiente): La operación aún no se ha completado.
- **Fulfilled** (resuelta): La operación se completó con éxito.
- **Rejected** (rechazada): La operación falló.

#### Estructura de una promesa

```javascript
const promesa = new Promise((resolve, reject) => {
  setTimeout(() => {
    const exito = true;
    if (exito) {
      resolve('¡Operación exitosa!');
    } else {
      reject(new Error('Algo salió mal'));
    }
  }, 2000);
});

promesa
  .then((resultado) => {
    console.log(resultado); // ¡Operación exitosa!
  })
  .catch((error) => {
    console.error(error.message); // Algo salió mal
  });
```

Las promesas permiten encadenar operaciones con **`.then()`** y manejar errores con **`.catch()`**, lo que mejora la legibilidad respecto a los callbacks.

### 3. Async/Await

La sintaxis **`async/await`** es una forma más moderna y legible de trabajar con promesas. Una función marcada con la palabra clave **`async`** siempre devuelve una promesa, y dentro de ella se puede usar **`await`** para esperar a que una promesa se resuelva.

#### Ejemplo de async/await

```javascript
async function obtenerDatos() {
  try {
    const respuesta = await fetch('http://localhost:3000/datos');
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    const datos = await respuesta.json();
    console.log('Datos recibidos:', datos);
  } catch (error) {
    console.error('Error:', error.message);
  }
}

obtenerDatos();
```

**Ventajas de async/await**:
- Código más limpio y similar al síncrono.
- Mejor manejo de errores con bloques `try/catch`.
- Evita el encadenamiento excesivo de `.then()`.

---

## La API `fetch`

La API **`fetch`** es una interfaz moderna de JavaScript que permite realizar solicitudes HTTP (como GET, POST, PUT, DELETE, etc.) de manera sencilla. Es más limpia que la antigua `XMLHttpRequest` y está basada en promesas.

### Características de `fetch`

- **Basada en promesas**: Devuelve una promesa que se resuelve en un objeto `Response`.
- **Soporte para múltiples formatos**: Puede manejar JSON, texto, blobs, etc.
- **Configuración flexible**: Permite configurar headers, métodos, cuerpos de solicitud, etc.
- **No rechaza automáticamente en errores HTTP**: A diferencia de otras APIs, `fetch` no rechaza la promesa en errores como `404` o `500`; en su lugar, devuelve un objeto `Response` con la propiedad `ok` en `false`.

### Estructura básica de una solicitud con `fetch`

```javascript
fetch('http://localhost:3000/datos')
  .then((respuesta) => {
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    return respuesta.json();
  })
  .then((datos) => {
    console.log('Datos:', datos);
  })
  .catch((error) => {
    console.error('Error:', error.message);
  });
```

Con **async/await**, la misma solicitud se escribiría así:

```javascript
async function obtenerDatos() {
  try {
    const respuesta = await fetch('http://localhost:3000/datos');
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    const datos = await respuesta.json();
    console.log('Datos:', datos);
  } catch (error) {
    console.error('Error:', error.message);
  }
}

obtenerDatos();
```

---

## Uso de Mockoon para simular APIs

**Mockoon** es una herramienta de código abierto que permite crear servidores API simulados de manera local. Es ideal para pruebas durante el desarrollo, ya que no requiere una conexión a internet ni un servidor remoto real. Con Mockoon, puedes definir endpoints, respuestas, códigos de estado, retardos, y más, todo desde una interfaz gráfica o archivos de configuración JSON.

### Configuración básica de Mockoon

1. **Descarga e instalación**:
   - Descarga Mockoon desde su sitio oficial: [https://mockoon.com/](https://mockoon.com/).
   - Instala la aplicación en tu sistema operativo (disponible para Windows, macOS y Linux).

2. **Crear un servidor simulado**:
   - Abre Mockoon y crea un nuevo entorno.
   - Define un puerto (por ejemplo, `3000`).
   - Agrega un endpoint, como `GET /datos`, con una respuesta JSON predefinida, por ejemplo:
     ```json
     [
       { "id": 1, "nombre": "Juan Pérez", "email": "juan@example.com" },
       { "id": 2, "nombre": "María Gómez", "email": "maria@example.com" }
     ]
     ```
   - Guarda la configuración y inicia el servidor.

3. **Probar el endpoint**:
   - Usa una herramienta como `curl`, Postman, o un navegador para verificar que el endpoint `http://localhost:3000/datos` devuelve la respuesta esperada.

### Configuración de Mockoon para los ejemplos

Para los ejemplos a continuación, asumimos que has configurado Mockoon con los siguientes endpoints:

- **GET /datos**: Devuelve una lista de usuarios en formato JSON.
- **POST /usuarios**: Acepta un objeto JSON con datos de un usuario y devuelve el usuario creado con un ID asignado.
- **GET /error**: Devuelve un error 500 para simular un fallo del servidor.

El archivo de configuración de Mockoon (exportado como JSON) podría verse así:

```json
{
  "port": 3000,
  "routes": [
    {
      "method": "GET",
      "path": "/datos",
      "response": {
        "status": 200,
        "body": "[{\"id\":1,\"nombre\":\"Juan Pérez\",\"email\":\"juan@example.com\"},{\"id\":2,\"nombre\":\"María Gómez\",\"email\":\"maria@example.com\"}]"
      }
    },
    {
      "method": "POST",
      "path": "/usuarios",
      "response": {
        "status": 201,
        "body": "{\"id\":{{body.id || 999}},\"nombre\":\"{{body.nombre}}\",\"email\":\"{{body.email}}\"}"
      }
    },
    {
      "method": "GET",
      "path": "/error",
      "response": {
        "status": 500,
        "body": "{\"error\":\"Error interno del servidor\"}"
      }
    }
  ]
}
```

Guarda este archivo (por ejemplo, `mockoon-config.json`) e impórtalo en Mockoon para iniciar el servidor en `http://localhost:3000`.

---

## Ejemplos prácticos completos con Mockoon

A continuación, presento ejemplos que utilizan `fetch` para interactuar con los endpoints simulados en Mockoon, combinando promesas, async/await y manejo de errores.

### Ejemplo 1: Solicitud GET con Mockoon

Este ejemplo obtiene la lista de usuarios desde el endpoint `GET /datos` de Mockoon.

```javascript
async function obtenerUsuariosMockoon() {
  try {
    const respuesta = await fetch('http://localhost:3000/datos');
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    const usuarios = await respuesta.json();
    console.log('Usuarios obtenidos desde Mockoon:', usuarios);
  } catch (error) {
    console.error('Error al obtener usuarios:', error.message);
  }
}

obtenerUsuariosMockoon();
```

**Explicación**:
- La solicitud se realiza al endpoint `http://localhost:3000/datos` configurado en Mockoon.
- Se verifica si la respuesta es exitosa con `respuesta.ok`.
- Los datos JSON se procesan y se imprimen en la consola.
- Si el servidor Mockoon no está corriendo, se captura un error de red.

**Salida esperada**:
```javascript
Usuarios obtenidos desde Mockoon: [
  { id: 1, nombre: 'Juan Pérez', email: 'juan@example.com' },
  { id: 2, nombre: 'María Gómez', email: 'maria@example.com' }
]
```

### Ejemplo 2: Solicitud POST con Mockoon

Este ejemplo envía una solicitud POST al endpoint `POST /usuarios` para crear un nuevo usuario.

```javascript
async function crearUsuarioMockoon() {
  try {
    const nuevoUsuario = {
      nombre: 'Ana López',
      email: 'ana@example.com',
    };

    const respuesta = await fetch('http://localhost:3000/usuarios', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(nuevoUsuario),
    });

    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }

    const usuarioCreado = await respuesta.json();
    console.log('Usuario creado en Mockoon:', usuarioCreado);
  } catch (error) {
    console.error('Error al crear usuario:', error.message);
  }
}

crearUsuarioMockoon();
```

**Explicación**:
- Se envía un objeto JSON con los datos del usuario al endpoint `POST /usuarios`.
- Mockoon responde con el mismo objeto, añadiendo un campo `id` (según la configuración).
- La respuesta se procesa y se imprime en la consola.

**Salida esperada**:
```javascript
Usuario creado en Mockoon: {
  id: 999,
  nombre: 'Ana López',
  email: 'ana@example.com'
}
```

### Ejemplo 3: Manejo de errores con Mockoon

Este ejemplo realiza una solicitud al endpoint `GET /error` que devuelve un error 500.

```javascript
async function probarErrorMockoon() {
  try {
    const respuesta = await fetch('http://localhost:3000/error');
    if (!respuesta.ok) {
      const errorData = await respuesta.json();
      throw new Error(`Error HTTP ${respuesta.status}: ${errorData.error}`);
    }
    const datos = await respuesta.json();
    console.log('Datos:', datos);
  } catch (error) {
    console.error('Error capturado:', error.message);
  }
}

probarErrorMockoon();
```

**Explicación**:
- La solicitud se realiza al endpoint `GET /error`, que está configurado para devolver un error 500.
- Se verifica `respuesta.ok` y, al ser `false`, se lanza un error con el mensaje proporcionado por Mockoon.
- El bloque `catch` captura y muestra el error.

**Salida esperada**:
```javascript
Error capturado: Error HTTP 500: Error interno del servidor
```

### Ejemplo 4: Aplicación web simple con Mockoon

Este ejemplo crea una página web que usa `fetch` para interactuar con los endpoints de Mockoon y muestra los resultados en el DOM.

```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Interfaz con Mockoon</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    #resultado { margin-top: 20px; }
    button { padding: 10px; margin: 5px; }
  </style>
</head>
<body>
  <h1>Interfaz con Mockoon</h1>
  <button onclick="obtenerUsuarios()">Obtener Usuarios</button>
  <button onclick="crearUsuario()">Crear Usuario</button>
  <div id="resultado"></div>

  <script>
    async function obtenerUsuarios() {
      try {
        const respuesta = await fetch('http://localhost:3000/datos');
        if (!respuesta.ok) {
          throw new Error(`Error HTTP: ${respuesta.status}`);
        }
        const usuarios = await respuesta.json();
        mostrarResultado('Usuarios:', usuarios);
      } catch (error) {
        mostrarResultado('Error:', error.message);
      }
    }

    async function crearUsuario() {
      try {
        const nuevoUsuario = {
          nombre: 'Usuario Nuevo',
          email: 'nuevo@example.com',
        };
        const respuesta = await fetch('http://localhost:3000/usuarios', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(nuevoUsuario),
        });
        if (!respuesta.ok) {
          throw new Error(`Error HTTP: ${respuesta.status}`);
        }
        const usuarioCreado = await respuesta.json();
        mostrarResultado('Usuario creado:', usuarioCreado);
      } catch (error) {
        mostrarResultado('Error:', error.message);
      }
    }

    function mostrarResultado(titulo, datos) {
      const resultadoDiv = document.getElementById('resultado');
      resultadoDiv.innerHTML = `<h2>${titulo}</h2><pre>${JSON.stringify(datos, null, 2)}</pre>`;
    }
  </script>
</body>
</html>
```

**Explicación**:
- Se crea una página HTML con dos botones: uno para obtener usuarios (`GET /datos`) y otro para crear un usuario (`POST /usuarios`).
- Las funciones `obtenerUsuarios` y `crearUsuario` usan `fetch` con async/await para interactuar con los endpoints de Mockoon.
- Los resultados o errores se muestran en el DOM usando la función `mostrarResultado`.
- El servidor Mockoon debe estar corriendo en `http://localhost:3000` para que las solicitudes funcionen.

**Instrucciones**:
1. Guarda el código en un archivo `index.html`.
2. Asegúrate de que Mockoon esté ejecutando el servidor con los endpoints configurados.
3. Abre `index.html` en un navegador y haz clic en los botones para probar las solicitudes.

---

## Buenas prácticas y manejo de errores

1. **Siempre verifica `response.ok`**:
   - Comprueba si la respuesta HTTP es exitosa antes de procesarla.
   - Ejemplo: `if (!respuesta.ok) { throw new Error('Error HTTP') }`.

2. **Maneja errores con `try/catch`**:
   - Usa bloques `try/catch` con `async/await` para capturar errores de red o de la API.

3. **Configura headers adecuadamente**:
   - Incluye headers como `Content-Type` o `Authorization` cuando sea necesario.

4. **Usa `Promise.all` para solicitudes paralelas**:
   - Mejora el rendimiento ejecutando múltiples solicitudes simultáneamente.

5. **Implementa reintentos para errores transitorios**:
   - Si una solicitud falla por un problema de red, considera reintentarla un número limitado de veces.

6. **Valida los datos antes de enviarlos**:
   - Asegúrate de que los datos enviados en solicitudes POST/PUT estén en el formato correcto.

7. **Usa un tiempo de espera (timeout)**:
   - Configura un tiempo máximo para las solicitudes para evitar que se cuelguen indefinidamente.

8. **Pruebas con Mockoon**:
   - Usa Mockoon para simular diferentes escenarios (éxito, errores, retardos) y probar cómo tu aplicación maneja cada caso.
   - Configura respuestas dinámicas en Mockoon para simular datos realistas o errores específicos.

```javascript
async function fetchConTimeout(url, opciones, timeout = 5000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);

  try {
    const respuesta = await fetch(url, {
      ...opciones,
      signal: controller.signal,
    });
    clearTimeout(id);
    return respuesta;
  } catch (error) {
    clearTimeout(id);
    throw error;
  }
}

async function ejemploTimeoutMockoon() {
  try {
    const respuesta = await fetchConTimeout('http://localhost:3000/datos', {}, 3000);
    const datos = await respuesta.json();
    console.log('Datos:', datos);
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('La solicitud excedió el tiempo límite');
    } else {
      console.error('Error:', error.message);
    }
  }
}

ejemploTimeoutMockoon();
```

---
