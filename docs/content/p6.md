# Métodos Asíncronos y Fetch en JavaScript con Mockoon Playground

## Introducción

JavaScript es un lenguaje de programación que, por naturaleza, es **síncrono** y de un solo hilo, lo que significa que ejecuta una tarea a la vez en un orden secuencial. Sin embargo, muchas operaciones, como solicitudes HTTP, acceso a bases de datos o lectura de archivos, son **asíncronas** porque pueden tardar un tiempo indeterminado en completarse. Para manejar estas operaciones, JavaScript proporciona mecanismos como **callbacks**, **promesas**, y las palabras clave **`async/await`**, junto con la API moderna **`fetch`** para realizar solicitudes HTTP.

En este documento, exploraremos en detalle:

1. **¿Qué es la programación asíncrona?**
2. **Mecanismos para manejar asincronía en JavaScript**:
      - Callbacks
      - Promesas
      - Async/Await
3. **La API `fetch`: cómo realizar solicitudes HTTP**
4. **Uso de Mockoon Playground para probar APIs**
5. **Ejemplos prácticos completos con Mockoon Playground**
6. **Buenas prácticas y manejo de errores**

Los ejemplos utilizan el endpoint público de Mockoon Playground en `https://playground.mockoon.com/users`, que proporciona una API simulada para pruebas sin necesidad de configurar un servidor local.

---

## ¿Qué es la programación asíncrona?

La programación asíncrona permite que el código continúe ejecutándose mientras se espera que una operación de larga duración (como una solicitud HTTP) se complete, sin bloquear el hilo principal. Esto es crucial en aplicaciones web para mejorar la experiencia del usuario, ya que evita que la interfaz se "congele" mientras se espera una respuesta.

JavaScript utiliza el **event loop** (bucle de eventos) para manejar operaciones asíncronas. El event loop permite que las tareas asíncronas se procesen en segundo plano y se ejecuten una vez que estén listas, mientras el resto del código sigue ejecutándose.

---

## Mecanismos para manejar asincronía en JavaScript

### 1. Callbacks

Los **callbacks** son funciones que se pasan como argumentos a otras funciones y se ejecutan una vez que la operación asíncrona ha terminado. Aunque son un enfoque antiguo, es importante entenderlos porque son la base de los métodos modernos.

#### Ejemplo de callback

```javascript
function obtenerDatos(url, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.onload = function () {
    if (xhr.status === 200) {
      callback(null, JSON.parse(xhr.responseText));
    } else {
      callback(new Error('Error en la solicitud'), null);
    }
  };
  xhr.onerror = function () {
    callback(new Error('Error de red'), null);
  };
  xhr.send();
}

obtenerDatos('https://playground.mockoon.com/users', function (error, datos) {
  if (error) {
    console.error('Error:', error.message);
    return;
  }
  console.log('Datos recibidos:', datos);
});
```

**Problema con callbacks**: Cuando se anidan múltiples callbacks, se genera el problema conocido como **"callback hell"** o "pirámide de la fatalidad", que hace que el código sea difícil de leer y mantener.

### 2. Promesas

Las **promesas** son objetos que representan la eventual finalización (o falla) de una operación asíncrona. Una promesa puede estar en uno de tres estados:

- **Pending** (pendiente): La operación aún no se ha completado.
- **Fulfilled** (resuelta): La operación se completó con éxito.
- **Rejected** (rechazada): La operación falló.

#### Estructura de una promesa

```javascript
const promesa = new Promise((resolve, reject) => {
  setTimeout(() => {
    const exito = true;
    if (exito) {
      resolve('¡Operación exitosa!');
    } else {
      reject(new Error('Algo salió mal'));
    }
  }, 2000);
});

promesa
  .then((resultado) => {
    console.log(resultado); // ¡Operación exitosa!
  })
  .catch((error) => {
    console.error(error.message); // Algo salió mal
  });
```

Las promesas permiten encadenar operaciones con **`.then()`** y manejar errores con **`.catch()`**, lo que mejora la legibilidad respecto a los callbacks.

### 3. Async/Await

La sintaxis **`async/await`** es una forma más moderna y legible de trabajar con promesas. Una función marcada con la palabra clave **`async`** siempre devuelve una promesa, y dentro de ella se puede usar **`await`** para esperar a que una promesa se resuelva.

#### Ejemplo de async/await

```javascript
async function obtenerDatos() {
  try {
    const respuesta = await fetch('https://playground.mockoon.com/users');
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    const datos = await respuesta.json();
    console.log('Datos recibidos:', datos);
  } catch (error) {
    console.error('Error:', error.message);
  }
}

obtenerDatos();
```

**Ventajas de async/await**:

- Código más limpio y similar al síncrono.
- Mejor manejo de errores con bloques `try/catch`.
- Evita el encadenamiento excesivo de `.then()`.

---

## La API `fetch`

La API **`fetch`** es una interfaz moderna de JavaScript que permite realizar solicitudes HTTP (como GET, POST, PUT, DELETE, etc.) de manera sencilla. Es más limpia que la antigua `XMLHttpRequest` y está basada en promesas.

### Características de `fetch`

- **Basada en promesas**: Devuelve una promesa que se resuelve en un objeto `Response`.
- **Soporte para múltiples formatos**: Puede manejar JSON, texto, blobs, etc.
- **Configuración flexible**: Permite configurar headers, métodos, cuerpos de solicitud, etc.
- **No rechaza automáticamente en errores HTTP**: A diferencia de otras APIs, `fetch` no rechaza la promesa en errores como `404` o `500`; en su lugar, devuelve un objeto `Response` con la propiedad `ok` en `false`.

### Estructura básica de una solicitud con `fetch`

```javascript
fetch('https://playground.mockoon.com/users')
  .then((respuesta) => {
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    return respuesta.json();
  })
  .then((datos) => {
    console.log('Datos:', datos);
  })
  .catch((error) => {
    console.error('Error:', error.message);
  });
```

Con **async/await**, la misma solicitud se escribiría así:

```javascript
async function obtenerDatos() {
  try {
    const respuesta = await fetch('https://playground.mockoon.com/users');
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    const datos = await respuesta.json();
    console.log('Datos:', datos);
  } catch (error) {
    console.error('Error:', error.message);
  }
}

obtenerDatos();
```

---

## Uso de Mockoon Playground para probar APIs

**Mockoon Playground** es un servicio en línea proporcionado por Mockoon que ofrece endpoints API simulados para pruebas rápidas. El endpoint `https://playground.mockoon.com/users` devuelve una lista de usuarios en formato JSON, ideal para probar solicitudes HTTP sin necesidad de configurar un servidor local.

### Características del endpoint `https://playground.mockoon.com/users`

- **Método**: GET
- **Respuesta**: Lista de usuarios en formato JSON, por ejemplo:
  ```json
  [
    { "id": 1, "name": "John Doe", "email": "john.doe@example.com" },
    { "id": 2, "name": "Jane Smith", "email": "jane.smith@example.com" }
  ]
  ```
- **Limitaciones**: El playground es de solo lectura (soporta principalmente GET). Solicitudes como POST o PUT no están habilitadas en este endpoint público.

Debido a las limitaciones del playground, los ejemplos se centrarán en solicitudes GET y simularán escenarios de error (como tiempos de espera o fallos de red) en lugar de POST, ya que el endpoint no soporta escritura.

---

## Ejemplos prácticos completos con Mockoon Playground

A continuación, presento ejemplos que utilizan `fetch` para interactuar con el endpoint `https://playground.mockoon.com/users`, combinando promesas, async/await y manejo de errores.

### Ejemplo 1: Solicitud GET con Mockoon Playground

Este ejemplo obtiene la lista de usuarios desde el endpoint `GET https://playground.mockoon.com/users`.

```javascript
async function obtenerUsuariosPlayground() {
  try {
    const respuesta = await fetch('https://playground.mockoon.com/users');
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    const usuarios = await respuesta.json();
    console.log('Usuarios obtenidos desde Mockoon Playground:', usuarios);
  } catch (error) {
    console.error('Error al obtener usuarios:', error.message);
  }
}

obtenerUsuariosPlayground();
```

**Explicación**:

- La solicitud se realiza al endpoint `https://playground.mockoon.com/users`.
- Se verifica si la respuesta es exitosa con `respuesta.ok`.
- Los datos JSON se procesan y se imprimen en la consola.
- Si hay un error de red (por ejemplo, falta de conexión), se captura en el bloque `catch`.

**Salida esperada** (puede variar según el estado del playground):

```javascript
Usuarios obtenidos desde Mockoon Playground: [
  { id: 1, name: 'John Doe', email: 'john.doe@example.com' },
  { id: 2, name: 'Jane Smith', email: 'jane.smith@example.com' }
]
```

### Ejemplo 2: Simulación de solicitud POST (nota aclaratoria)

Dado que el endpoint `https://playground.mockoon.com/users` no soporta solicitudes POST, este ejemplo muestra cómo se escribiría el código si el endpoint lo permitiera, junto con una nota aclaratoria.

```javascript
async function crearUsuarioPlayground() {
  console.warn('Nota: El endpoint https://playground.mockoon.com/users no soporta POST. Este es un ejemplo ilustrativo.');
  try {
    const nuevoUsuario = {
      name: 'Ana López',
      email: 'ana.lopez@example.com',
    };

    const respuesta = await fetch('https://playground.mockoon.com/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(nuevoUsuario),
    });

    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }

    const usuarioCreado = await respuesta.json();
    console.log('Usuario creado en Mockoon Playground:', usuarioCreado);
  } catch (error) {
    console.error('Error al crear usuario:', error.message);
  }
}

crearUsuarioPlayground();
```

**Explicación**:

- Este código intenta enviar una solicitud POST, pero el endpoint del playground devolverá un error (por ejemplo, 405 Method Not Allowed).
- La advertencia inicial aclara que el endpoint no soporta POST, y el ejemplo sirve como referencia para casos donde se use un endpoint que sí lo permita.
- Para probar solicitudes POST reales, se recomienda configurar un servidor Mockoon local o usar otra API que soporte escritura.

**Salida esperada**:
```javascript
Nota: El endpoint https://playground.mockoon.com/users no soporta POST. Este es un ejemplo ilustrativo.
Error al crear usuario: Error HTTP: 405
```

### Ejemplo 3: Manejo de errores con tiempo de espera

Este ejemplo implementa un tiempo de espera para la solicitud GET, simulando un escenario donde la respuesta del servidor es demasiado lenta.

```javascript
async function fetchConTimeout(url, opciones, timeout = 5000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);

  try {
    const respuesta = await fetch(url, {
      ...opciones,
      signal: controller.signal,
    });
    clearTimeout(id);
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    return respuesta;
  } catch (error) {
    clearTimeout(id);
    throw error;
  }
}

async function obtenerUsuariosConTimeout() {
  try {
    const respuesta = await fetchConTimeout('https://playground.mockoon.com/users', {}, 3000);
    const usuarios = await respuesta.json();
    console.log('Usuarios obtenidos:', usuarios);
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Error: La solicitud excedió el tiempo límite de 3 segundos');
    } else {
      console.error('Error:', error.message);
    }
  }
}

obtenerUsuariosConTimeout();
```

**Explicación**:

- La función `fetchConTimeout` agrega un tiempo de espera a la solicitud usando `AbortController`.
- Si la solicitud tarda más de 3 segundos, se lanza un `AbortError`.
- Este ejemplo es útil para manejar APIs externas como el Mockoon Playground, donde los tiempos de respuesta pueden variar.

**Salida esperada** (si la solicitud es rápida):
```javascript
Usuarios obtenidos: [
  { id: 1, name: 'John Doe', email: 'john.doe@example.com' },
  { id: 2, name: 'Jane Smith', email: 'jane.smith@example.com' }
]
```

**Salida esperada** (si la solicitud excede el tiempo):
```javascript
Error: La solicitud excedió el tiempo límite de 3 segundos
```

### Ejemplo 4: Aplicación web simple con Mockoon Playground

Este ejemplo crea una página web que usa `fetch` para obtener usuarios desde `https://playground.mockoon.com/users` y muestra los resultados en el DOM.

```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Interfaz con Mockoon Playground</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    #resultado { margin-top: 20px; }
    button { padding: 10px; margin: 5px; }
  </style>
</head>
<body>
  <h1>Interfaz con Mockoon Playground</h1>
  <button onclick="obtenerUsuarios()">Obtener Usuarios</button>
  <div id="resultado"></div>

  <script>
    async function obtenerUsuarios() {
      try {
        const respuesta = await fetch('https://playground.mockoon.com/users');
        if (!respuesta.ok) {
          throw new Error(`Error HTTP: ${respuesta.status}`);
        }
        const usuarios = await respuesta.json();
        mostrarResultado('Usuarios:', usuarios);
      } catch (error) {
        mostrarResultado('Error:', error.message);
      }
    }

    function mostrarResultado(titulo, datos) {
      const resultadoDiv = document.getElementById('resultado');
      resultadoDiv.innerHTML = `<h2>${titulo}</h2><pre>${JSON.stringify(datos, null, 2)}</pre>`;
    }
  </script>
</body>
</html>
```

**Explicación**:

- Se crea una página HTML con un botón para obtener usuarios desde `https://playground.mockoon.com/users`.
- La función `obtenerUsuarios` usa `fetch` con async/await para realizar la solicitud.
- Los resultados o errores se muestran en el DOM usando la función `mostrarResultado`.
- No se incluye un botón para POST debido a las limitaciones del endpoint.

**Instrucciones**:
1. Guarda el código en un archivo `index.html`.
2. Abre `index.html` en un navegador (puedes usar un servidor local como `Live Server` en VS Code para evitar problemas de CORS, aunque el endpoint de Mockoon Playground suele incluir headers CORS permisivos).
3. Haz clic en el botón para ver la lista de usuarios.

---
