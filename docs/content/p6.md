# Métodos Asíncronos y Fetch en JavaScript con Mockoon Playground

## Introducción

JavaScript es un lenguaje de programación que, por naturaleza, es **síncrono** y de un solo hilo, lo que significa que ejecuta una tarea a la vez en un orden secuencial. Sin embargo, muchas operaciones, como solicitudes HTTP, acceso a bases de datos o lectura de archivos, son **asíncronas** porque pueden tardar un tiempo indeterminado en completarse. Para manejar estas operaciones, JavaScript proporciona mecanismos como **callbacks**, **promesas**, y las palabras clave **`async/await`**, junto con la API moderna **`fetch`** para realizar solicitudes HTTP.

En este documento, exploraremos en detalle:

1. **¿Qué es la programación asíncrona?**
2. **Mecanismos para manejar asincronía en JavaScript**:
      - Callbacks
      - Promesas
      - Async/Await
3. **La API `fetch`: cómo realizar solicitudes HTTP**
4. **Uso de Mockoon Playground para probar APIs**
5. **Ejemplos prácticos completos con Mockoon Playground**
6. **Buenas prácticas y manejo de errores**

Los ejemplos utilizan el endpoint público de Mockoon Playground en `https://playground.mockoon.com/users`, que proporciona una API simulada para pruebas sin necesidad de configurar un servidor local.

---

## ¿Qué es la programación asíncrona?

La programación asíncrona permite que el código continúe ejecutándose mientras se espera que una operación de larga duración (como una solicitud HTTP) se complete, sin bloquear el hilo principal. Esto es crucial en aplicaciones web para mejorar la experiencia del usuario, ya que evita que la interfaz se "congele" mientras se espera una respuesta.

JavaScript utiliza el **event loop** (bucle de eventos) para manejar operaciones asíncronas. El event loop permite que las tareas asíncronas se procesen en segundo plano y se ejecuten una vez que estén listas, mientras el resto del código sigue ejecutándose.

---

## Mecanismos para manejar asincronía en JavaScript

### 1. Callbacks

Los **callbacks** son funciones que se pasan como argumentos a otras funciones y se ejecutan una vez que la operación asíncrona ha terminado. Aunque son un enfoque antiguo, es importante entenderlos porque son la base de los métodos modernos.

#### Ejemplo de callback

```javascript
function obtenerDatos(url, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.onload = function () {
    if (xhr.status === 200) {
      callback(null, JSON.parse(xhr.responseText));
    } else {
      callback(new Error('Error en la solicitud'), null);
    }
  };
  xhr.onerror = function () {
    callback(new Error('Error de red'), null);
  };
  xhr.send();
}

obtenerDatos('https://playground.mockoon.com/users', function (error, datos) {
  if (error) {
    console.error('Error:', error.message);
    return;
  }
  console.log('Datos recibidos:', datos);
});
```

**Problema con callbacks**: Cuando se anidan múltiples callbacks, se genera el problema conocido como **"callback hell"** o "pirámide de la fatalidad", que hace que el código sea difícil de leer y mantener.

### 2. Promesas

Las **promesas** son objetos que representan la eventual finalización (o falla) de una operación asíncrona. Una promesa puede estar en uno de tres estados:

- **Pending** (pendiente): La operación aún no se ha completado.
- **Fulfilled** (resuelta): La operación se completó con éxito.
- **Rejected** (rechazada): La operación falló.

#### Estructura de una promesa

```javascript
const promesa = new Promise((resolve, reject) => {
  setTimeout(() => {
    const exito = true;
    if (exito) {
      resolve('¡Operación exitosa!');
    } else {
      reject(new Error('Algo salió mal'));
    }
  }, 2000);
});

promesa
  .then((resultado) => {
    console.log(resultado); // ¡Operación exitosa!
  })
  .catch((error) => {
    console.error(error.message); // Algo salió mal
  });
```

Las promesas permiten encadenar operaciones con **`.then()`** y manejar errores con **`.catch()`**, lo que mejora la legibilidad respecto a los callbacks.

### 3. Async/Await

La sintaxis **`async/await`** es una forma más moderna y legible de trabajar con promesas. Una función marcada con la palabra clave **`async`** siempre devuelve una promesa, y dentro de ella se puede usar **`await`** para esperar a que una promesa se resuelva.

#### Ejemplo de async/await

```javascript
async function obtenerDatos() {
  try {
    const respuesta = await fetch('https://playground.mockoon.com/users');
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    const datos = await respuesta.json();
    console.log('Datos recibidos:', datos);
  } catch (error) {
    console.error('Error:', error.message);
  }
}

obtenerDatos();
```

**Ventajas de async/await**:

- Código más limpio y similar al síncrono.
- Mejor manejo de errores con bloques `try/catch`.
- Evita el encadenamiento excesivo de `.then()`.

---

## La API `fetch`

La API **`fetch`** es una interfaz moderna de JavaScript que permite realizar solicitudes HTTP (como GET, POST, PUT, DELETE, etc.) de manera sencilla. Es más limpia que la antigua `XMLHttpRequest` y está basada en promesas.

### Características de `fetch`

- **Basada en promesas**: Devuelve una promesa que se resuelve en un objeto `Response`.
- **Soporte para múltiples formatos**: Puede manejar JSON, texto, blobs, etc.
- **Configuración flexible**: Permite configurar headers, métodos, cuerpos de solicitud, etc.
- **No rechaza automáticamente en errores HTTP**: A diferencia de otras APIs, `fetch` no rechaza la promesa en errores como `404` o `500`; en su lugar, devuelve un objeto `Response` con la propiedad `ok` en `false`.

### Estructura básica de una solicitud con `fetch`

```javascript
fetch('https://playground.mockoon.com/users')
  .then((respuesta) => {
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    return respuesta.json();
  })
  .then((datos) => {
    console.log('Datos:', datos);
  })
  .catch((error) => {
    console.error('Error:', error.message);
  });
```

Con **async/await**, la misma solicitud se escribiría así:

```javascript
async function obtenerDatos() {
  try {
    const respuesta = await fetch('https://playground.mockoon.com/users');
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    const datos = await respuesta.json();
    console.log('Datos:', datos);
  } catch (error) {
    console.error('Error:', error.message);
  }
}

obtenerDatos();
```

---

## Uso de Mockoon Playground para probar APIs

**Mockoon Playground** es un servicio en línea proporcionado por Mockoon que ofrece endpoints API simulados para pruebas rápidas. El endpoint `https://playground.mockoon.com/users` devuelve una lista de usuarios en formato JSON, ideal para probar solicitudes HTTP sin necesidad de configurar un servidor local.

### Características del endpoint `https://playground.mockoon.com/users`

- **Método**: GET
- **Respuesta**: Lista de usuarios en formato JSON, por ejemplo:
  ```json
  [
    { "id": 1, "name": "John Doe", "email": "john.doe@example.com" },
    { "id": 2, "name": "Jane Smith", "email": "jane.smith@example.com" }
  ]
  ```
- **Limitaciones**: El playground es de solo lectura (soporta principalmente GET). Solicitudes como POST o PUT no están habilitadas en este endpoint público.

Debido a las limitaciones del playground, los ejemplos se centrarán en solicitudes GET y simularán escenarios de error (como tiempos de espera o fallos de red) en lugar de POST, ya que el endpoint no soporta escritura.

---

## Ejemplos prácticos completos con Mockoon Playground

A continuación, presento ejemplos que utilizan `fetch` para interactuar con el endpoint `https://playground.mockoon.com/users`, combinando promesas, async/await y manejo de errores.

### Ejemplo 1: Solicitud GET con Mockoon Playground

Este ejemplo obtiene la lista de usuarios desde el endpoint `GET https://playground.mockoon.com/users`.

```javascript
async function obtenerUsuariosPlayground() {
  try {
    const respuesta = await fetch('https://playground.mockoon.com/users');
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    const usuarios = await respuesta.json();
    console.log('Usuarios obtenidos desde Mockoon Playground:', usuarios);
  } catch (error) {
    console.error('Error al obtener usuarios:', error.message);
  }
}

obtenerUsuariosPlayground();
```

**Explicación**:

- La solicitud se realiza al endpoint `https://playground.mockoon.com/users`.
- Se verifica si la respuesta es exitosa con `respuesta.ok`.
- Los datos JSON se procesan y se imprimen en la consola.
- Si hay un error de red (por ejemplo, falta de conexión), se captura en el bloque `catch`.

**Salida esperada** (puede variar según el estado del playground):

```javascript
Usuarios obtenidos desde Mockoon Playground: [
  { id: 1, name: 'John Doe', email: 'john.doe@example.com' },
  { id: 2, name: 'Jane Smith', email: 'jane.smith@example.com' }
]
```

### Ejemplo 2: Simulación de solicitud POST (nota aclaratoria)

Dado que el endpoint `https://playground.mockoon.com/users` no soporta solicitudes POST, este ejemplo muestra cómo se escribiría el código si el endpoint lo permitiera, junto con una nota aclaratoria.

```javascript
async function crearUsuarioPlayground() {
  console.warn('Nota: El endpoint https://playground.mockoon.com/users no soporta POST. Este es un ejemplo ilustrativo.');
  try {
    const nuevoUsuario = {
      name: 'Ana López',
      email: 'ana.lopez@example.com',
    };

    const respuesta = await fetch('https://playground.mockoon.com/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(nuevoUsuario),
    });

    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }

    const usuarioCreado = await respuesta.json();
    console.log('Usuario creado en Mockoon Playground:', usuarioCreado);
  } catch (error) {
    console.error('Error al crear usuario:', error.message);
  }
}

crearUsuarioPlayground();
```

**Explicación**:

- Este código intenta enviar una solicitud POST, pero el endpoint del playground devolverá un error (por ejemplo, 405 Method Not Allowed).
- La advertencia inicial aclara que el endpoint no soporta POST, y el ejemplo sirve como referencia para casos donde se use un endpoint que sí lo permita.
- Para probar solicitudes POST reales, se recomienda configurar un servidor Mockoon local o usar otra API que soporte escritura.

**Salida esperada**:
```javascript
Nota: El endpoint https://playground.mockoon.com/users no soporta POST. Este es un ejemplo ilustrativo.
Error al crear usuario: Error HTTP: 405
```

### Ejemplo 3: Manejo de errores con tiempo de espera

Este ejemplo implementa un tiempo de espera para la solicitud GET, simulando un escenario donde la respuesta del servidor es demasiado lenta.

```javascript
async function fetchConTimeout(url, opciones, timeout = 5000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);

  try {
    const respuesta = await fetch(url, {
      ...opciones,
      signal: controller.signal,
    });
    clearTimeout(id);
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    return respuesta;
  } catch (error) {
    clearTimeout(id);
    throw error;
  }
}

async function obtenerUsuariosConTimeout() {
  try {
    const respuesta = await fetchConTimeout('https://playground.mockoon.com/users', {}, 3000);
    const usuarios = await respuesta.json();
    console.log('Usuarios obtenidos:', usuarios);
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Error: La solicitud excedió el tiempo límite de 3 segundos');
    } else {
      console.error('Error:', error.message);
    }
  }
}

obtenerUsuariosConTimeout();
```

**Explicación**:

- La función `fetchConTimeout` agrega un tiempo de espera a la solicitud usando `AbortController`.
- Si la solicitud tarda más de 3 segundos, se lanza un `AbortError`.
- Este ejemplo es útil para manejar APIs externas como el Mockoon Playground, donde los tiempos de respuesta pueden variar.

**Salida esperada** (si la solicitud es rápida):
```javascript
Usuarios obtenidos: [
  { id: 1, name: 'John Doe', email: 'john.doe@example.com' },
  { id: 2, name: 'Jane Smith', email: 'jane.smith@example.com' }
]
```

**Salida esperada** (si la solicitud excede el tiempo):
```javascript
Error: La solicitud excedió el tiempo límite de 3 segundos
```

### Ejemplo 4: Aplicación web simple con Mockoon Playground

Este ejemplo crea una página web que usa `fetch` para obtener usuarios desde `https://playground.mockoon.com/users` y muestra los resultados en el DOM.

```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Interfaz con Mockoon Playground</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    #resultado { margin-top: 20px; }
    button { padding: 10px; margin: 5px; }
  </style>
</head>
<body>
  <h1>Interfaz con Mockoon Playground</h1>
  <button onclick="obtenerUsuarios()">Obtener Usuarios</button>
  <div id="resultado"></div>

  <script>
    async function obtenerUsuarios() {
      try {
        const respuesta = await fetch('https://playground.mockoon.com/users');
        if (!respuesta.ok) {
          throw new Error(`Error HTTP: ${respuesta.status}`);
        }
        const usuarios = await respuesta.json();
        mostrarResultado('Usuarios:', usuarios);
      } catch (error) {
        mostrarResultado('Error:', error.message);
      }
    }

    function mostrarResultado(titulo, datos) {
      const resultadoDiv = document.getElementById('resultado');
      resultadoDiv.innerHTML = `<h2>${titulo}</h2><pre>${JSON.stringify(datos, null, 2)}</pre>`;
    }
  </script>
</body>
</html>
```

**Explicación**:

- Se crea una página HTML con un botón para obtener usuarios desde `https://playground.mockoon.com/users`.
- La función `obtenerUsuarios` usa `fetch` con async/await para realizar la solicitud.
- Los resultados o errores se muestran en el DOM usando la función `mostrarResultado`.
- No se incluye un botón para POST debido a las limitaciones del endpoint.

**Instrucciones**:

1. Guarda el código en un archivo `index.html`.
2. Abre `index.html` en un navegador (puedes usar un servidor local como `Live Server` en VS Code para evitar problemas de CORS, aunque el endpoint de Mockoon Playground suele incluir headers CORS permisivos).
3. Haz clic en el botón para ver la lista de usuarios.

## Ejercicios Fetch y Tabla con Async/Await

## Modelo de Datos
```json
[
  {
    "id": 1,
    "name": "string",
    "email": "string@domain.com",
    "age": 30
  }
]
```

## Ejercicio 1: Cargar usuarios básicos
```html
<table id="table1"></table>
<script>
async function loadUsers1() {
  try {
    const res = await fetch('https://api.example.com/users');
    const data = await res.json();
    const table = document.getElementById('table1');
    table.innerHTML = '<tr><th>ID</th><th>Name</th></tr>' +
      data.map(user => `<tr><td>${user.id}</td><td>${user.name}</td></tr>`).join('');
  } catch (err) {
    console.error(err);
  }
}
loadUsers1();
</script>
```

## Ejercicio 2: Mostrar email y edad
```html
<table id="table2"></table>
<script>
async function loadUsers2() {
  try {
    const res = await fetch('https://api.example.com/users');
    const data = await res.json();
    const table = document.getElementById('table2');
    table.innerHTML = '<tr><th>Email</th><th>Age</th></tr>' +
      data.map(user => `<tr><td>${user.email}</td><td>${user.age}</td></tr>`).join('');
  } catch (err) {
    console.error(err);
  }
}
loadUsers2();
</script>
```

## Ejercicio 3: Filtrar mayores de 25
```html
<table id="table3"></table>
<script>
async function loadUsers3() {
  try {
    const res = await fetch('https://api.example.com/users');
    const data = await res.json();
    const table = document.getElementById('table3');
    table.innerHTML = '<tr><th>Name</th><th>Age</th></tr>' +
      data
        .filter(user => user.age > 25)
        .map(user => `<tr><td>${user.name}</td><td>${user.age}</td></tr>`).join('');
  } catch (err) {
    console.error(err);
  }
}
loadUsers3();
</script>
```

## Ejercicio 4: Ordenar por nombre
```html
<table id="table4"></table>
<script>
async function loadUsers4() {
  try {
    const res = await fetch('https://api.example.com/users');
    const data = await res.json();
    const table = document.getElementById('table4');
    table.innerHTML = '<tr><th>ID</th><th>Name</th></tr>' +
      data
        .sort((a, b) => a.name.localeCompare(b.name))
        .map(user => `<tr><td>${user.id}</td><td>${user.name}</td></tr>`).join('');
  } catch (err) {
    console.error(err);
  }
}
loadUsers4();
</script>
```

## Ejercicio 5: Manejo de errores
```html
<table id="table5"></table>
<script>
async function loadUsers5() {
  try {
    const res = await fetch('https://api.example.com/users');
    const data = await res.json();
    const table = document.getElementById('table5');
    table.innerHTML = '<tr><th>Name</th><th>Email</th></tr>' +
      data.map(user => `<tr><td>${user.name}</td><td>${user.email}</td></tr>`).join('');
  } catch (err) {
    document.getElementById('table5').innerHTML = '<tr><td>Error loading data</td></tr>';
  }
}
loadUsers5();
</script>
```

## Tutorial: Manipulación de Tablas HTML con JavaScript

Este tutorial cubre todas las formas de manipular una tabla HTML ya creada utilizando JavaScript. Se asume que tienes una tabla básica en tu HTML y deseas modificarla dinámicamente. El tutorial está estructurado para ser claro y práctico, con ejemplos de código que puedes probar directamente.

## 1. Introducción

Las tablas HTML (`<table>`) son elementos comunes para mostrar datos estructurados. JavaScript permite manipular estas tablas dinámicamente, lo que incluye agregar, eliminar o modificar filas, celdas, contenido, estilos y atributos. Este tutorial utiliza el DOM (Document Object Model) para realizar estas operaciones.

## 2. Estructura HTML Base

Para los ejemplos, usaremos la siguiente tabla HTML:

```html
<table id="miTabla" border="1">
  <thead>
    <tr>
      <th>Nombre</th>
      <th>Edad</th>
      <th>Ciudad</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Juan</td>
      <td>25</td>
      <td>Madrid</td>
    </tr>
    <tr>
      <td>María</td>
      <td>30</td>
      <td>Barcelona</td>
    </tr>
  </tbody>
</table>
```

El atributo `id="miTabla"` facilita la selección de la tabla con JavaScript. Asegúrate de incluir esta tabla en tu archivo HTML antes de ejecutar los scripts.

## 3. Seleccionar una Tabla

Para manipular una tabla, primero debes seleccionarla. Aquí hay varias formas de hacerlo:

```javascript
// Seleccionar por ID
const tabla = document.getElementById('miTabla');

// Seleccionar por clase (si tiene class="tabla")
const tablaPorClase = document.querySelector('.tabla');

// Seleccionar todas las tablas
const todasLasTablas = document.getElementsByTagName('table');

// Seleccionar la primera tabla
const primeraTabla = document.querySelector('table');
```

**Nota:** Usaremos `document.getElementById('miTabla')` en los ejemplos por simplicidad.

## 4. Manipular Filas

Las filas de una tabla se representan con el elemento `<tr>`. Puedes agregar, eliminar o modificar filas en el `<tbody>` o `<thead>`.

### 4.1 Agregar una Fila

Para agregar una fila al `<tbody>`:

```javascript
const tabla = document.getElementById('miTabla');
const tbody = tabla.getElementsByTagName('tbody')[0];
const nuevaFila = tbody.insertRow(); // Inserta al final

// Agregar celdas a la fila
const celda1 = nuevaFila.insertCell();
const celda2 = nuevaFila.insertCell();
const celda3 = nuevaFila.insertCell();

celda1.textContent = 'Pedro';
celda2.textContent = '28';
celda3.textContent = 'Sevilla';
```

También puedes especificar el índice donde insertar la fila:

```javascript
const nuevaFila = tbody.insertRow(0); // Inserta en la primera posición
```

### 4.2 Eliminar una Fila

Para eliminar una fila específica:

```javascript
const tabla = document.getElementById('miTabla');
const tbody = tabla.getElementsByTagName('tbody')[0];
tbody.deleteRow(0); // Elimina la primera fila
```

Para eliminar todas las filas:

```javascript
while (tbody.rows.length > 0) {
  tbody.deleteRow(0);
}
```

### 4.3 Modificar una Fila

Para modificar el contenido de una fila existente:

```javascript
const tabla = document.getElementById('miTabla');
const fila = tabla.rows[1]; // Segunda fila (índice 1)
fila.cells[0].textContent = 'Ana'; // Cambia la primera celda
fila.cells[1].textContent = '35';
fila.cells[2].textContent = 'Valencia';
```

## 5. Manipular Celdas

Las celdas se representan con `<td>` (o `<th>` en encabezados). Puedes manipularlas individualmente.

### 5.1 Agregar una Celda

Para agregar una celda a una fila existente:

```javascript
const tabla = document.getElementById('miTabla');
const fila = tabla.rows[1];
const nuevaCelda = fila.insertCell(); // Inserta al final
nuevaCelda.textContent = 'Nueva Celda';
```

### 5.2 Eliminar una Celda

Para eliminar una celda específica:

```javascript
const tabla = document.getElementById('miTabla');
const fila = tabla.rows[1];
fila.deleteCell(0); // Elimina la primera celda
```

### 5.3 Modificar una Celda

Para cambiar el contenido de una celda:

```javascript
const tabla = document.getElementById('miTabla');
const celda = tabla.rows[1].cells[0];
celda.textContent = 'Modificado';
```

## 6. Manipular Contenido de la Tabla

Además de filas y celdas, puedes modificar el contenido, atributos y estilos de la tabla.

### 6.1 Cambiar Texto o HTML

Para cambiar el texto:

```javascript
const celda = document.getElementById('miTabla').rows[1].cells[0];
celda.textContent = 'Nuevo Texto';
```

Para insertar HTML:

```javascript
celda.innerHTML = '<strong>Texto en negrita</strong>';
```

### 6.2 Agregar Atributos

Para agregar o modificar atributos:

```javascript
const tabla = document.getElementById('miTabla');
tabla.setAttribute('class', 'tabla-estilizada');
tabla.rows[1].cells[0].setAttribute('data-id', '123');
```

### 6.3 Modificar Estilos

Para cambiar estilos con CSS:

```javascript
const tabla = document.getElementById('miTabla');
tabla.style.border = '2px solid blue';
tabla.rows[1].cells[0].style.backgroundColor = 'yellow';
```

O usando clases CSS:

```javascript
tabla.classList.add('borde-azul');
```

## 7. Iterar Sobre Filas y Celdas

Puedes recorrer todas las filas y celdas para realizar operaciones masivas:

```javascript
const tabla = document.getElementById('miTabla');
for (let fila of tabla.rows) {
  for (let celda of fila.cells) {
    celda.style.backgroundColor = 'lightgray';
  }
}
```

## 8. Manipular Encabezados (thead) y Cuerpo (tbody)

Para trabajar específicamente con `<thead>` o `<tbody>`:

```javascript
const tabla = document.getElementById('miTabla');
const thead = tabla.getElementsByTagName('thead')[0];
const tbody = tabla.getElementsByTagName('tbody')[0];

// Agregar una fila al thead
const nuevaFilaThead = thead.insertRow();
const celdaThead = nuevaFilaThead.insertCell();
celdaThead.textContent = 'Nuevo Encabezado';
```

## 9. Ejemplo Completo

Aquí tienes un ejemplo completo que combina varias operaciones:

```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Manipulación de Tablas</title>
  <style>
    table { border-collapse: collapse; }
    th, td { border: 1px solid black; padding: 8px; }
    .resaltado { background-color: yellow; }
  </style>
</head>
<body>
  <table id="miTabla">
    <thead>
      <tr>
        <th>Nombre</th>
        <th>Edad</th>
        <th>Ciudad</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Juan</td>
        <td>25</td>
        <td>Madrid</td>
      </tr>
      <tr>
        <td>María</td>
        <td>30</td>
        <td>Barcelona</td>
      </tr>
    </tbody>
  </table>

  <script>
    const tabla = document.getElementById('miTabla');
    const tbody = tabla.getElementsByTagName('tbody')[0];

    // Agregar una fila
    const nuevaFila = tbody.insertRow();
    nuevaFila.insertCell().textContent = 'Pedro';
    nuevaFila.insertCell().textContent = '28';
    nuevaFila.insertCell().textContent = 'Sevilla';

    // Modificar una celda
    tabla.rows[1].cells[0].textContent = 'Ana';

    // Resaltar filas pares
    for (let i = 0; i < tbody.rows.length; i++) {
      if (i % 2 === 0) {
        tbody.rows[i].classList.add('resaltado');
      }
    }

    // Eliminar la segunda fila
    tbody.deleteRow(1);
  </script>
</body>
</html>
```

---
## Actividad: Consumo de la API de Películas con Mockoon Playground (POST y PUT habilitados)

## Introducción

En esta actividad, practicarás el uso de métodos asíncronos en JavaScript, específicamente la API **`fetch`** y la sintaxis **`async/await`**, para interactuar con el endpoint público de Mockoon Playground en `https://playground.mockoon.com/movies`. Este endpoint devuelve una lista de películas en formato JSON y soporta solicitudes GET, POST y PUT, lo que permite realizar operaciones de lectura, creación y actualización de películas.

La actividad está diseñada para reforzar tus habilidades en:

- Realizar solicitudes HTTP (GET, POST, PUT) usando `fetch`.
- Manejar respuestas asíncronas con `async/await`.
- Procesar datos JSON y mostrarlos en una interfaz web.
- Implementar manejo de errores para escenarios como fallos de red o respuestas no exitosas.

## Objetivos

1. Realizar una solicitud GET al endpoint `https://playground.mockoon.com/movies` para obtener una lista de películas.
2. Crear una nueva película usando una solicitud POST con un objeto JSON proporcionado.
3. Actualizar una película existente usando una solicitud PUT.
4. Crear una página web que muestre la lista de películas en una tabla HTML y permita crear o actualizar películas.
5. Implementar manejo de errores para mostrar mensajes al usuario en caso de fallos.

## Requisitos previos

- Conocimientos básicos de HTML, CSS y JavaScript.
- Comprensión de promesas y `async/await` en JavaScript.
- Un navegador web moderno (como Chrome o Firefox).
- Un editor de código (como VS Code) y, opcionalmente, una extensión como Live Server para servir la página HTML localmente.

## Descripción del endpoint

El endpoint `https://playground.mockoon.com/movies` es un servicio público de Mockoon Playground que simula una API de películas. Sus características son:

- **Método GET**:
    - **URL**: `https://playground.mockoon.com/movies`
    - **Respuesta**: Un arreglo de objetos JSON con información de películas, por ejemplo:
      ```json
      [
        {
          "id": 1,
          "title": "The Shawshank Redemption",
          "year": 1994,
          "director": "Frank Darabont",
          "genre": "Drama",
          "rating": 9.3,
          "isPopular": true
        },
        {
          "id": 2,
          "title": "The Godfather",
          "year": 1972,
          "director": "Francis Ford Coppola",
          "genre": "Crime",
          "rating": 9.2,
          "isPopular": true
        }
      ]
      ```

- **Método POST**:
  
    - **URL**: `https://playground.mockoon.com/movies`
    - **Cuerpo**: Objeto JSON con los campos `title`, `year`, `director`, `genre`, `rating`, `isPopular`.
    - **Respuesta**: Devuelve el objeto creado con un `id` asignado por la API.

- **Método PUT**:
  
    - **URL**: `https://playground.mockoon.com/movies/:id` (por ejemplo, `https://playground.mockoon.com/movies/1`)
    - **Cuerpo**: Objeto JSON con los campos a actualizar.
    - **Respuesta**: Devuelve el objeto actualizado.

- **Notas**: El endpoint es público y soporta CORS, por lo que no requiere configuración adicional para pruebas desde un navegador.

## Instrucciones

Sigue estos pasos para completar la actividad:

1. **Crea la estructura HTML**:
   
      - Crea un archivo `index.html` con una interfaz que incluya:
        - Un botón para cargar la lista de películas (GET).
        - Un formulario para crear una nueva película (POST).
        - Un formulario para actualizar una película existente (PUT).
        - Una tabla para mostrar las películas.
        - Un área para mostrar mensajes de error.
      - Añade estilos CSS para que la interfaz sea clara y legible.

2. **Implementa la lógica JavaScript**:
   
      - Escribe funciones asíncronas para:
        - Obtener la lista de películas (`GET`).
        - Crear una nueva película (`POST`) usando el objeto JSON corregido.
        - Actualizar una película existente (`PUT`).
      - Usa `fetch` con `async/await` y maneja errores con `try/catch`.
      - Actualiza dinámicamente la tabla con los resultados.

3. **Prueba la aplicación**:
   
      - Abre `index.html` en un navegador (usa un servidor local si es necesario).
      - Prueba cargar las películas, crear una nueva película y actualizar una existente.
      - Simula errores (por ejemplo, enviando un ID inválido en PUT) para verificar el manejo de errores.


## Plantilla inicial

Aquí tienes una plantilla inicial para `index.html`:

```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Solución: Gestión de Películas</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 900px;
      margin: 0 auto;
    }
    h1, h2 {
      color: #333;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
      cursor: pointer;
    }
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    #error, #exito {
      margin-top: 10px;
      padding: 10px;
      border-radius: 5px;
    }
    #error {
      color: red;
      background-color: #ffe6e6;
    }
    #exito {
      color: green;
      background-color: #e6ffe6;
    }
    #loading {
      color: #007bff;
      font-weight: bold;
      margin-top: 10px;
    }
    button, input[type="submit"] {
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover, input[type="submit"]:hover {
      background-color: #0056b3;
    }
    form {
      margin: 20px 0;
      padding: 15px;
      background-color: #f8f8f8;
      border-radius: 5px;
    }
    label {
      display: block;
      margin: 8px 0;
    }
    input[type="text"], input[type="number"] {
      padding: 8px;
      width: 100%;
      max-width: 300px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    input[type="checkbox"] {
      margin-left: 10px;
    }
  </style>
</head>
<body>
  <h1>Gestión de Películas</h1>
  <button onclick="cargarPeliculas()">Cargar Películas</button>
  <div id="loading" style="display: none;">Cargando...</div>

  <h2>Crear Nueva Película</h2>
  <form id="form-crear" onsubmit="event.preventDefault(); crearPelicula();">
    <label>Título: <input type="text" id="crear-titulo" required></label>
    <label>Género: <input type="text" id="crear-genero" required></label>
    <label>Director: <input type="text" id="crear-director" required></label>
    <label>Año: <input type="number" id="crear-anio" min="1888" max="2025" required></label>
    <label>Calificación: <input type="number" id="crear-rating" step="0.1" min="0" max="10" required></label>
    <label>Popular: <input type="checkbox" id="crear-popular"></label>
    <input type="submit" value="Crear Película">
  </form>

  <h2>Actualizar Película</h2>
  <form id="form-actualizar" onsubmit="event.preventDefault(); actualizarPelicula();">
    <label>ID: <input type="text" id="actualizar-id" required></label>
    <label>Título: <input type="text" id="actualizar-titulo" required></label>
    <label>Género: <input type="text" id="actualizar-genero" required></label>
    <label>Director: <input type="text" id="actualizar-director" required></label>
    <label>Año: <input type="number" id="actualizar-anio" min="1888" max="2025" required></label>
    <label>Calificación: <input type="number" id="actualizar-rating" step="0.1" min="0" max="10" required></label>
    <label>Popular: <input type="checkbox" id="actualizar-popular"></label>
    <input type="submit" value="Actualizar Película">
  </form>

  <table id="tabla-peliculas">
    <thead>
      <tr>
        <th>ID</th>
        <th>Título</th>
        <th>Género</th>
        <th>Director</th>
        <th>Año</th>
        <th>Calificación</th>
        <th>Popular</th>
      </tr>
    </thead>
    <tbody id="cuerpo-tabla"></tbody>
  </table>
  <div id="exito"></div>
  <div id="error"></div>

  <script>
   

    // Cargar películas (GET)
    async function cargarPeliculas() {
      
    }

    // Crear película (POST)
    async function crearPelicula() {
      
    }

    // Actualizar película (PUT)
    async function actualizarPelicula() {
      
    }
  </script>
</body>
</html>
```

## Tareas a completar

1. **Implementa la función `cargarPeliculas`**:
   
      - Usa `fetch` con `async/await` para obtener las películas de `https://playground.mockoon.com/movies`.
      - Verifica que la respuesta sea exitosa (`response.ok`).
      - Rellena la tabla con los datos obtenidos.

2. **Implementa la función `crearPelicula`**:
   
      - Obtén los datos del formulario de creación.
      - Envía una solicitud POST con el objeto JSON corregido.
      - Actualiza la tabla con la nueva película.

3. **Implementa la función `actualizarPelicula`**:
   
      - Obtén los datos del formulario de actualización, incluyendo el ID.
      - Envía una solicitud PUT al endpoint `https://playground.mockoon.com/movies/:id`.
      - Actualiza la tabla con los datos modificados.

